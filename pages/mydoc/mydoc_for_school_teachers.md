---
title: PascalABC.NET для учителей и преподавателей
keywords: styles
last_updated: 01.04.2020
sidebar: mydoc_sidebar
permalink: mydoc_for_school_teachers.html
toc: false
folder: mydoc
---

## Введение

PascalABC.NET активно используется в школах и университетах России. 

Данный текст предназначен преимущественно для школьных учителей и преподавателей дополнительного образования, но в равной степени может использоваться всеми для введения в новые возможности языка PascalABC.NET.
Здесь содержится также описание стиля программирования, который мы рекомендуем использовать при обучении. Кроме того, объясняются методические причины использования тех или иных конструкций.

### Совместимость с Borland Pascal, Free Pascal

PascalABC.NET имеет высокую совместимость с Borland Pascal, Free Pascal и позволяет писать программы "в старом стиле". Однако старый стиль не рекомендуется к использованию, поскольку основное предназначение PascalABC.NET в образовании - обучение современному программированию.

### Целесообразность обучения новым конструкциям

Для нас очевидно, что обучение программированию с опорой только на "базовый Паскаль" лишено будущего. 
"Старый Паскаль" опирается на конструкции и стиль как минимум 30-летней давности и устарел. Это создаёт неприятные ситуации при обучении на этом языке: многие учениики видят в сети современные примеры программирования на других языках, и это отталкивает от обучения программированию на "базовом Паскале". 

PascalABC.NET как раз и создавался с целью интегрировать новые конструкции, возникающие в современных языках программирования, и затем использовать их в обучении. В этом отношении мы стремились сделать PascalABC.NET столь же лаконичным, как язык Python, но со всеми преимуществами языка компиляционного типа. Проверка ошибок на этапе компиляции играет огромную роль в написании правильных программ, что особенно важно для начинающих.

### Какой язык использовать для обучения программированию

Бытует мнение что лучше учить сразу языкам, используемым в промышленных проектах: Python, C++, Java, C#. Здесь каждый преподаватель принимает решение сам - всё зависит от его искусства. Однако отметим, что ученика, который мечтает стать лётчиком, в школе никто не учит летать на промышленных самолётах :) 

PascalABC.NET обеспечивает учителя и ученика простой и мощной оболочкой с подробной справочной системой, сообщениями об ошибках на русском языке, а также с системой подсказок по коду (почти отсутствующей у Python-оболочек). 

PascalABC.NET даже в простейших программах использует такие важные конструкции и концепции как автовывод типов и кортежи, а использование лямбда-выражений и последовательностей многократно упрощает решение стандартных задач. По существу все эти конструкции являются **новыми примитивами программирования**, необходимыми современному школьнику.

Кроме того, в PascalABC.NET имеются мощные библиотеки "на все случаи жизни", а также собственные модули упрощённой графики для визуализаций, простых анимаций и простых интерактивных приложений. 

Ни одна из известных нам систем программирования не располагает подобным сочетанием средств, необходимых в первую очередь для обучения.

## Базовые конструкции

### Описания переменных внутри блока и автовывод типов

В большинстве случаев переменные описываются в блоке begin-end и описание совмещается с инициализацией:

```pascal
begin
  var a := 5;
  var r := 3.14;
  var s := 'ABC';
end.
```

Это решает сразу несколько проблем:
- можно не говорить о типах в первых программах или лишь упоминать их
- невозможно забыть инициализировать переменную
- переменные описываются по мере необходимости близко к месту их использования. Это улучшает читаемость. Проблема старого Паскаля, когда груда переменных описывалась до beginа, отсутствует

При таком способе возникает одна проблема: если надо накопить сумму вещественных, то такой код приведет к ошибке типов:
```pascal
begin
  var sum := 0;
  loop 10 do
    sum += ReadReal;
end.
```

Для исправления этой ошибки всё равно придётся говорить о типах и инициализировать sum одним из двух способов:
```pascal
  var sum := 0.0;
```
или
```pascal
  var sum : real := 0;
```

### Цикл for var

Переменная - счётчик цикла for всегда должна описываться в заголовке цикла: 
```pascal
  for var i:=1 to 9 do
    Print(i);
  for var i:=21 to 29 do
    Print(i);
```

Это делает невозможным использование счётчика цикла вне цикла 

### Цикл loop

Если количество повторений цикла заранее известно, но неважен номер повторения, то используется цикл loop:
```pascal
  loop 9 do
    Write('*');
```

### Множественное описание переменных с инициализацией

Можно инициализировать сразу несколько переменных в момент описания:

```pascal
  var (a,b) := (1,2);
  var (Имя,Возраст) := ('Иванов',15);
```

### Вывод

Для вывода вместо процедуры Write предпочтительно использовать процедуру Print. В отличие от Write она разделяет элементы вывода пробелами. Например:
```pascal
begin
  var (a,b,c) := (1,2,3);
  Println(a,b,c);
  for var i:=1 to 9 do
    Print(i);
end.
```

Для вывода нескольких значений с пояснениями рекомендуется использовать интерполированные строки:
```pascal
begin
  var (a,b) := ReadInteger2;
  Println($'Сумма {a} и {b} равна {a + b}');
end.
```

вместо режущего глаз
```pascal
  Writeln('Сумма ', a ' и ', b, ' равна ', a + b);
```

### Ввод

Ввод принято осуществлять, используя функции вида ReadInteger, ReadReal и т.д.:

```pascal
begin
  var a := ReadInteger;
end.
```

Это позволяет совмещать описание переменной с инициализацией и автовыводом типа. В качестве дополнительных бонусов: можно делать приглашение к вводу как параметр функции ввода и вводить сразу несколько переменных одного типа:

```pascal
begin
  var a := ReadReal('Введите a: ');
  var (m,n,p) := ReadInteger3;
  var (x,y) := ReadReal2('Введите координаты точки: ');
end.
```

Для ввода с контролем ошибок используется функция TryRead. Она возвращает False если ввод осуществлён неверно (введено не число или число выходит за границы диапазона). Типичный пример её использования: 

```pascal
begin
  var i: integer;
  while not TryRead(i,'Введите i:') do
    Println('Повторите ввод!');
end.
```

### Тип BigInteger

Для работы с длинными целыми используется тип BigInteger. Например, чтобы вычислить 100!, достаточно написать следующий код:

```pascal
begin
  var p: BigInteger := 1;
  for var i := 2 to 100 do
    p *= i;
  Println(p);  
end.
```

### Некоторые полезные стандартные процедуры, функции и операции

Для обмена значений двух переменных `a` и `b` используйте стандартную функцию `Swap(a,b)`:
```pascal
begin
  var a,b := ReadReal2;
  Println(a,b);
  Swap(a,b);
  Println(a,b);
end.
```

Разумеется, первый раз необходимо показать, что обмен значений осуществляется через третью переменную:
```pascal
begin
  var a,b := ReadReal2;
  Println(a,b);
  var t := a;
  a := b;
  b := t;
  Println(a,b);
end.
```

Но далее следует использовать Swap.

Минимальное и максимальное среди множества значений можно вычислить, используя стандартные функции Min и Max: 

```pascal
begin
  var a,b,c,d := ReadReal4;
  Println(Min(a,b),Max(c,d));
  Println(Min(a,b,c,d)); // произвольное количество значений
end.
```

Для возведения в степень используется операция `**`:

```pascal
begin
  Println(2 ** 10);
  Println(2 ** 0.5);
end.
```
Возведение в целую степень оптимизировано и работает быстрее стандартной функции `Power(a,n)`.

Для проверки принадлежности диапазону используется конструкция `x in a..b`:
```pascal
begin
  var x := ReadInteger;
  if x in 10..99 then
    Print('Двузначное число');
end.
```
Эта операция эффективна и переводится в 
```pascal
begin
  var x := ReadInteger;
  if (x >= 10) and (x <= 99) then
    Print('Двузначное число');
end.
```

Заметим, что для проверки принадлежности множеству значений используется классическая операция `x in [2,3,5,7,11]`, но она неэффективна ни по скорости ни по памяти.

### Условная операция

Если переменной необходимо присвоить значение в зависимости от условия, то вместо условного оператора иногда нагляднее использовать условную операцию:

```pascal
begin
  var (a,b) := ReadInteger2;
  var min := if a<b then a else b;
  Print(min);
end.
```




### Кортежи

Кортежи представляют собой способ объединить несколько значений в одно целое. Значения типа Кортеж записываются в круглых скобках: `(1,2,3)` или `('Иванов',15)`. с помощью кортежей можно выполнять одновременные присваивания нескольким переменным:

```pascal
begin
  var a,b: integer;
  (a,b) := (3,5);
  (a,b) := (b,a);
end.
```

Присваивание `(a,b) := (b,a)` позволяет поменять значения двух переменных.

Использование кортежей даже в начальных задачах крайне многообразно.

**Пример 1.** Нахождение наибольшего общего делителя

```pascal
begin
  var (a,b) := ReadInteger2; 
  while b>0 do
    (a,b) := (b, a mod b);
  Print('НОД = ', a); 
end.
```

**Пример 2.** Числа Фибоначчи

```pascal
begin
  var (a,b) := (1,1); 
  loop 20 do
  begin
    Print(a); 
    (a,b) := (b, a + b);
  end;
end.
```

## Лямбда-выражения

## Массивы

## Последовательности

## Списки

## Двумерные массивы (матрицы)

## Строки

## Файлы

### Текстовые файлы

### Ттипизированные файлы


{% include links.html %}
