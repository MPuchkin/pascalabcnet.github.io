---
title: PascalABC.NET для учителей и преподавателей
keywords: styles
last_updated: 01.04.2020
sidebar: mydoc_sidebar
permalink: mydoc_for_school_teachers.html
toc: false
folder: mydoc
---

## Введение

PascalABC.NET активно используется в школах и университетах России. 

Данный текст предназначен преимущественно для школьных учителей и преподавателей дополнительного образования, но в равной степени может использоваться всеми для введения в новые возможности языка PascalABC.NET.
Здесь содержится также описание стиля программирования, который мы рекомендуем использовать при обучении. Кроме того, объясняются методические причины использования тех или иных конструкций.

### Совместимость с Borland Pascal, Free Pascal

PascalABC.NET имеет высокую совместимость с Borland Pascal, Free Pascal и позволяет писать программы "в старом стиле". Однако старый стиль не рекомендуется к использованию, поскольку основное предназначение PascalABC.NET в образовании - обучение современному программированию.

### Целесообразность обучения новым конструкциям

Для нас очевидно, что обучение программированию с опорой только на "базовый Паскаль" лишено будущего. 
"Старый Паскаль" опирается на конструкции и стиль как минимум 30-летней давности и устарел. Это создаёт неприятные ситуации при обучении на этом языке: многие учениики видят в сети современные примеры программирования на других языках, и это отталкивает от обучения программированию на "базовом Паскале". Здесь мы полностью согласны с часто высказываемым мнением "старый Паскаль умер".

PascalABC.NET как раз и создавался с целью интегрировать новые конструкции, возникающие в современных языках программирования, и затем использовать их в обучении. В этом отношении мы стремились сделать PascalABC.NET столь же лаконичным, как язык Python, но со всеми преимуществами языка компиляционного типа. Проверка ошибок на этапе компиляции играет огромную роль в написании правильных программ, что особенно важно для начинающих.

### Какой язык использовать для обучения программированию

Бытует мнение что лучше учить сразу языкам, используемым в промышленных проектах: Python, C++, Java, C#. Здесь каждый преподаватель принимает решение сам - всё зависит от его искусства. Однако отметим, что ученика, который мечтает стать лётчиком, в школе никто не учит летать на промышленных самолётах :) 

PascalABC.NET обеспечивает учителя и ученика простой и мощной оболочкой с подробной справочной системой, сообщениями об ошибках на русском языке, а также с системой подсказок по коду (почти отсутствующей у Python-оболочек). 

PascalABC.NET даже в простейших программах использует такие важные конструкции и концепции как автовывод типов и кортежи, а использование лямбда-выражений и последовательностей многократно упрощает решение стандартных задач. По существу все эти конструкции являются **новыми примитивами программирования**, необходимыми современному школьнику.

Кроме того, в PascalABC.NET имеются мощные библиотеки "на все случаи жизни", а также собственные модули упрощённой графики для визуализаций, простых анимаций и простых интерактивных приложений. 

Ни одна из известных нам систем программирования не располагает подобным сочетанием средств, необходимых в первую очередь для обучения.

## PascalABC.NET и ЕГЭ

Как и для любого языка, в ЕГЭ при написании программ на PascalABC.NET необходимо указывать версию языка Паскаль и его диалект. Мы рекомендуем указывать, что программа написана на языке PascalABC.NET версии 3.6 или выше. 

## Базовые конструкции

### Описания переменных внутри блока и автовывод типов

В большинстве случаев переменные описываются в блоке begin-end и описание совмещается с инициализацией:

```pascal
begin
  var a := 5;
  var r := 3.14;
  var s := 'ABC';
end.
```

Это решает сразу несколько проблем:
- можно не говорить о типах в первых программах или лишь упоминать их
- невозможно забыть инициализировать переменную
- переменные описываются по мере необходимости близко к месту их использования. Это улучшает читаемость. Проблема старого Паскаля, когда груда переменных описывалась до beginа, отсутствует

При таком способе возникает одна проблема: если надо накопить сумму вещественных, то такой код приведет к ошибке типов:
```pascal
begin
  var sum := 0;
  loop 10 do
    sum += ReadReal;
end.
```

Для исправления этой ошибки всё равно придётся говорить о типах и инициализировать sum одним из двух способов:
```pascal
var sum := 0.0;
```
или
```pascal
var sum : real := 0;
```

### Цикл for var

Переменная - счётчик цикла for всегда должна описываться в заголовке цикла: 
```pascal
for var i:=1 to 9 do
  Print(i);
for var i:=21 to 29 do
  Print(i);
```

Это делает невозможным использование счётчика цикла вне цикла 

### Цикл loop

Если количество повторений цикла заранее известно, но неважен номер повторения, то используется цикл loop:
```pascal
loop 9 do
  Write('*');
```

### Множественное описание переменных с инициализацией

Можно инициализировать сразу несколько переменных в момент описания:

```pascal
var (a,b) := (1,2);
var (Имя,Возраст) := ('Иванов',15);
```

### Вывод

Для вывода вместо процедуры Write предпочтительно использовать процедуру Print. В отличие от Write она разделяет элементы вывода пробелами. Например:
```pascal
begin
  var (a,b,c) := (1,2,3);
  Println(a,b,c);
  for var i:=1 to 9 do
    Print(i);
end.
```

Для вывода нескольких значений с пояснениями рекомендуется использовать интерполированные строки:
```pascal
begin
  var (a,b) := ReadInteger2;
  Println($'Сумма {a} и {b} равна {a + b}');
end.
```

вместо режущего глаз
```pascal
Writeln('Сумма ', a ' и ', b, ' равна ', a + b);
```

### Ввод

Ввод принято осуществлять, используя функции вида ReadInteger, ReadReal и т.д.:

```pascal
begin
  var a := ReadInteger;
end.
```

Это позволяет совмещать описание переменной с инициализацией и автовыводом типа. В качестве дополнительных бонусов: можно делать приглашение к вводу как параметр функции ввода и вводить сразу несколько переменных одного типа:

```pascal
begin
  var a := ReadReal('Введите a: ');
  var (m,n,p) := ReadInteger3;
  var (x,y) := ReadReal2('Введите координаты точки: ');
end.
```

Для ввода с контролем ошибок используется функция TryRead. Она возвращает False если ввод осуществлён неверно (введено не число или число выходит за границы диапазона). Типичный пример её использования: 

```pascal
begin
  var i: integer;
  while not TryRead(i,'Введите i:') do
    Println('Повторите ввод!');
end.
```

### Тип BigInteger

Для работы с длинными целыми используется тип BigInteger. Например, чтобы вычислить 100!, достаточно написать следующий код:

```pascal
begin
  var p: BigInteger := 1;
  for var i := 2 to 100 do
    p *= i;
  Println(p);  
end.
```

### Некоторые полезные стандартные процедуры, функции и операции

Для обмена значений двух переменных `a` и `b` используйте стандартную функцию `Swap(a,b)`:
```pascal
begin
  var a,b := ReadReal2;
  Println(a,b);
  Swap(a,b);
  Println(a,b);
end.
```

Разумеется, первый раз необходимо показать, что обмен значений осуществляется через третью переменную:
```pascal
begin
  var a,b := ReadReal2;
  Println(a,b);
  var t := a;
  a := b;
  b := t;
  Println(a,b);
end.
```

Но далее следует использовать Swap.

Минимальное и максимальное среди множества значений можно вычислить, используя стандартные функции Min и Max: 

```pascal
begin
  var a,b,c,d := ReadReal4;
  Println(Min(a,b),Max(c,d));
  Println(Min(a,b,c,d)); // произвольное количество значений
end.
```

Для возведения в степень используется операция `**`:

```pascal
begin
  Println(2 ** 10);
  Println(2 ** 0.5);
end.
```
Возведение в целую степень оптимизировано и работает быстрее стандартной функции `Power(a,n)`.

Для проверки принадлежности диапазону используется конструкция `x in a..b`:
```pascal
begin
  var x := ReadInteger;
  if x in 10..99 then
    Print('Двузначное число');
end.
```
Эта операция эффективна и переводится в 
```pascal
begin
  var x := ReadInteger;
  if (x >= 10) and (x <= 99) then
    Print('Двузначное число');
end.
```

Заметим, что для проверки принадлежности множеству значений используется классическая операция `x in [2,3,5,7,11]`, но она неэффективна ни по скорости ни по памяти.

### Условная операция

Если переменной необходимо присвоить значение в зависимости от условия, то вместо условного оператора иногда нагляднее использовать условную операцию:

```pascal
begin
  var (a,b) := ReadInteger2;
  var min := if a<b then a else b;
  Print(min);
end.
```

### Методы в стандартных типах

В PascalABC.NET внутри каждого типа имеется ряд полезных **методов**. В отличие от внешних процедур и функций, они "вшиты" в тип - переменная знает все свои методы и может вызывать их, используя **точечную нотацию**. 

Например, чтобы вывести значение переменной базового типа, можно 
использовать метод Print:

```pascal
begin
  var i: integer := 5;
  i.Print;
end.
```

Из других интересных методов для начинающих для целых типов отметим:
```pascal
i.IsEven - является ли i чётным
i.IsOdd - является ли i нечётным
i.InRange(a,b) - находится ли значение i между a и b (включительно)
i.Sqrt - квадратный корень
```

Например, в следующей программе вычисляется количество четных двузначных из 10 введённых:
```pascal
begin
  var count := 0;
  loop 10 do
  begin
    var x := ReadInteger;
    if i.IsEven and i.InRange(10,99) then // не требует написания скобок
      count += 1;
  end;
  count.Print
end.
```

Для вещественных значений полезными являются методы 
```pascal
r.Sqrt
r.Round
r.Trunc
r.InRange(a,b) - находится ли значение r между a и b (включительно)
```
В частности, удобно использовать цепочечную точечную нотацию: 
```pascal
begin
  var x := 17;
  var IsPrime := True;
  for var i:=2 to x.Sqrt.Round do
    if x mod i = 0 then
    begin
      IsPrime := False;
      break
    end;
  IsPrime.Print;
end.
```

Для всех числовых типов также определены константы MinValue и MaxValue. Чтобы обратиться к ним, следует использовать имя типа: 
```
integer.MinValue
real.MaxValue
```

### Кортежи

Кортежи представляют собой способ объединить несколько значений в одно целое. Значения типа Кортеж записываются в круглых скобках: `(1,2,3)` или `('Иванов',15)`. с помощью кортежей можно выполнять одновременные присваивания нескольким переменным:

```pascal
begin
  var a,b: integer;
  (a,b) := (3,5);
  (a,b) := (b,a);
end.
```

Присваивание `(a,b) := (b,a)` позволяет поменять значения двух переменных.

Использование кортежей даже в начальных задачах крайне многообразно.

**Пример 1.** Нахождение наибольшего общего делителя

```pascal
begin
  var (a,b) := ReadInteger2; 
  while b>0 do
    (a,b) := (b, a mod b);
  Print('НОД = ', a); 
end.
```

**Пример 2.** Числа Фибоначчи

```pascal
begin
  var (a,b) := (1,1); 
  loop 20 do
  begin
    Print(a); 
    (a,b) := (b, a + b);
  end;
end.
```

## Массивы

В PascalABC.NET рекомендуется использовать динамические массивы. В отличие от статических, они имеют огромное количество методов и операций, просты в создании, заполнении и выводе.

### Описание и выделение памяти

Динамический массив описывается так:
```pascal
begin
  var a: array of integer;
end.
```

Память под динамический массив a выделяется в момент работы программы:
```pascal
begin
  var a: array of integer;
  var n := ReadInteger;
  a := new integer[n];
end.
```

Здесь - первое преимущество динамических массивов - в переменной a может храниться массив любого размера, память выделяется в процессе работы программы. Кроме того, выделенная память гарантированно автоматически заполняется нулевыми значениями.

Можно совместить описание и выделение памяти - тип динамического массива выводится автоматически:
```pascal
begin
  var n := ReadInteger;
  var a := new integer[n];
end.
```

### Индексация в динамических массивах и использование статических массивов

Динамические массивы индексируются с нуля - это эффективно. В качестве индексов в динамических массивах могут выступать только целые.

Статические массивы тем не менее иногда удобно использовать - в задачах, где индексы либо символьные, либо по-существу начинаются не с нуля. Например, для подсчёта количества слов на каждую букву может использоваться стаический массив
```pascal
  var a := array ['a'..'z'] of integer;
```

Заполнение статических массивов - увы - производится в цикле. Кроме того, они не помнят свою длину и передача таких массивов в качестве параметров подпрограмм связана с техническими сложностями 40-летней давности, не нужными начинающим.


### Простейшее заполнение

Важную роль играют функции заполнения динамических массивов. Перед заполнением они выделяют для массива память, поэтому в одной строке можно совмещать описание, выделение памяти и заполнение.

Простейшее заполнение - набором значений:
```pascal
var a := Arr(1,3,3,7,9);
```

Заполнение диапазоном целых или символьных значений делается с использованием той же функции Arr:
```pascal
var a := Arr(1..9);
var b := Arr('a'..'z');
```

Заполнение определённым значением осуществляется с помощью ArrFill:
```pascal
begin
  var n := ReadInteger;
  var a := ArrFill(n,0); // массив из n нулей
end.
```

Для заполнения можно также использовать умножение массива на число:
```pascal
begin
  var n := ReadInteger;
  var a := Arr(0) * n; // массив из n нулей
end.
```

Для заполнения массива случайными значениями следует использовать 
```pascal
begin
  var n := ReadInteger;
  var a := ArrRandomInteger(n); // по умолчанию значения от 0 до 100
  var a1 := ArrRandomInteger(n,1,10); // случайные от 1 до 10
  var r := ArrRandomReal(n); // по умолчанию значения от 0 до 10
  var r1 := ArrRandomReal(n,2,5); // случайные вещественные от 2 до 5
end.
```

**Не рекомендуется** использовать алгоритм для заполнения массива случайными в каждой задаче:
```pascal
begin
  var n := ReadInteger;
  var a := new integer[n];
  for var i:=0 to n-1 do
    a[i] := Random(0,100);
end.
```
Повторять этот текст в каждой задаче - странно. Для этого есть стандартные функции.



### Ввод и вывод элементов массива

Для ввода элементов массива базовых типов используются функции
```pascal
begin
  var n := ReadInteger;
  var a := ReadArrInteger(n);
  var r := ReadArrReal(n);
  var s := ReadArrString(n);
  // ...
end.
```

Стандартная процедура вывода Write или Print выводит значения в массиве в квадратных скобках черезх запятую:
```pascal
begin
  var a := Arr(1..9);
  Print(a); // [1,2,3,4,5,6,7,8,9]
end.
```

Однако лучше всего для вывода воспользоваться методом Print, выводящим все значения в массиве через пробел:
```pascal
begin
  var a := Arr(1..9);
  a.Print; // 1 2 3 4 5 6 7 8 9 
end.
```

**Не рекомендуется** вводить и выводить элементы массива в цикле
```pascal
begin
  var n := ReadInteger;
  var a := new integer[n];
  for var i:=0 to n-1 do
    a[i] := ReadInteger;
end.
```
Повторять этот текст в каждой задаче - странно. Для этого есть стандартные функции.


### Циклы по массиву

Для обработки элементов массива используются следующие циклы:

1. Цикл for по индексам (если требуется менять элементв или нужна информация об индексах)
```pascal
for var i:=0 to a.Length-1 do
  a[i] *= 2;
```

2. Цикл foreach по элементам (если индексы не вадны и мы не меняем массив)
```pascal
var sum := 0;
foreach var x in a do
  sum += x;
```

3. Цикл foreach по индексам 
```pascal
foreach var x in a.Indices do
  a[i] += 2;
```

4. Цикл foreach по диапазону индексов 
```pascal
var (K,L) := ReadInteger2;
foreach var i in K..L do
  a[i] := 777;
```

**Пример**. Найти количество чётных элементов, стоящих на чётных местах

```pascal
begin
  var a := ArrRandomInteger(10);
  a.Println; 
  var count := 0;
  foreach var i in a.Indices do
    if i.IsEven and a[i].IsEven then
      count += 1;
  Print(count);    
end.
```

### Методы массива

Массивы содержат большое количество стандартных методов:

```pascal
a.Length - длина массива
a.Min - минимальный элемент в массиве
a.Max - максимальный элемент в массиве
a.IndexMin - индекс первого минимального элемента в массиве
a.IndexMax - индекс первого максимального элемента в массиве
a.Sum - сумма элементов в числовом массиве
a.Product - произведение элементов в числовом массиве
a.Average - среднее элементов в числовом массиве
a.First - первый элемент в массиве
a.Last - последний элемент в массиве
a.IndexOf(x) - индекс первого значения x или -1 если не найдено
a.Replace(x,y) - заменить в массиве все значения x на y
```

Кроме того, доступны процедуры 
```pascal
Sort(a) - сортировка элементов по возрастанию
SortDescending(a) - сортировка элементов по убыванию
Reverse(a) - инвертирование элементов массива
```


**Методика**. Обращаем внимание, что в методических целях естественно рассказывать, как эти алгоритмы устроены "внутри".
Но потом следует пользоваться стандартными алгоритмами, а не заставлять учеников во всех задачах использовать рукописные вортировки или рукописный поиск минимума. Например, рекомендуется показать, как накопить сумму элементов массива:

```pascal
begin
  var a := ArrRandomInteger(10);
  a.Println; 
  var sum := 0;
  foreach var x in a do
    sum += x;
  Print(sum);    
end.
```

Здесь следует обратить внимание, что этот алгоритм может быть легко модифицирован в алгоритм нахождения суммы элементов по условию: например, всех чётных элементов:

```pascal
begin
  var a := ArrRandomInteger(10);
  a.Println; 
  var sum := 0;
  foreach var x in a do
    if x.IsEven then
      sum += x;
  Print(sum);    
end.
```

Отметим, что заполнение случайными и вывод - это технические части программы, которые делаются в PascalABC.NET в одну строку, позволяя концентрироваться на алгоритме.

Если условие надо накладывать на индексы, то в этом случае (и только в этом случае) следует использовать цикл for по индексам:
```pascal
begin
  var a := ArrRandomInteger(10);
  a.Println; 
  var sum := 0;
  for var i:=0 to a.Length-1 do
    if i.IsEven then
      sum += a[i];
  Print(sum);    
end.
```

Для нахождения суммы без условия необходимо использовать стандартный метод a.Sum:
```pascal
begin
  var a := ArrRandomInteger(10);
  a.Println; 
  Print(a.Sum);    
end.
```

Отметим также, что для поиска суммы по условию также имеется короткая однострочная запись. Она требует использование стандартного метода Where с параметром, являющимся лямбда-выражением. Лямбда-выражения мы будем рассматривать далее: 
```pascal
begin
  var a := ArrRandomInteger(10);
  a.Println; 
  Print(a.Where(x -> x.IsEven).Sum);
end.
```

Поскольку данная запись использована здесь впервые, обращаем внимание на её высокую универсальность: алгоритмы фильтрации и поиска суммы не слиты в один алгоритм, а используются порознь один за другим, что позволяет:
1. Лучше читать код (потому что он записан компактно и методами с понятными и очевидынми названиями)
2. Лучше модифицировать код
3. Решать более сложные и более прикладные задачи за одно и то же время урока

далее лямбда-выражения объясняются подробно и тщательно и используются повсеместно.

### Операции с массивами

```pascal
x in a - возвращает true если значение x содержится в a
a1 + a2 - возвращает массив, образованный слиянием массивов a1 и a2
a1 * n - возвращает массив, состоящий из n раз повторенных значений массива a
```


### Динамические массивы как ссылки (дополнительный материал)

Важно понимать, что переменная типа массив - это всего лишь ссылка на элементы массива. При присваивании друг другу переменные типа массив начинают ссылаться на одну память: 
```pascal
  var a := Arr(1,2,3);
  var b := a;
  a[0] := 666;
  Print(b[0]); // 666
```
Поэтому a[0] и b[0] - это одна и та же ячейка памяти. С этим надо жить :)

## Лямбда-выражения

Лямбда-выражения - базовый примитив программирования на PascalABC.NET. При обучении начинающих они возникают как параметры стандартных подпрограмм и методов.

Учителю психологически трудно перейти на использование лямбда-выражений по нескольким причинам:
- лямбда-выражения кажутся сложными
- лямбда-выражения кажутся относящимися лишь к профессиональному программированию
- нигде в доступной учебной литературе не используются лямбда-выражения

Мы попытаемся развеять эти мифы. 

Итак: **лямбда-выражения - это просто**.

Лямбда-выражение - это **функция**. Функция отображает параметр на значение. Например, квадратичная функция в школе записывается как

```
f(x) = x * x
```
Её можно записать также в виде:
```
f: x -> x * x
```
что означает, что функция с именем f сопоставляет каждому `x` значение `x*x`. 

Запись `x -> x * x` и называется в PascalABC.NET лямбда-выражением или лямбда-функцией. Заметим, что в отличие от предыдущей записи лямбда-функция не имеет имени. Именно поэтому часто лямбда-функция называется **безымянной функцией**.

Другие примеры лямбда-функций: 

Линейная функция:
```
x -> 2*x + 3
```

Функция, проверяющая, чётно ли x, и возвращающая True если чётно и False в противном случае:
```
x -> x mod 2 = 0
```

## Последовательности

## Списки

## Двумерные массивы (матрицы)

## Строки

## Файлы

### Текстовые файлы

### Типизированные файлы


{% include links.html %}
