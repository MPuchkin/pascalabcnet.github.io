---
title: PascalABC.NET и ЕГЭ по информатике 2021
keywords: styles
last_updated: 07.01.2020
sidebar: mydoc_sidebar
permalink: mydoc_for_EGE.html
toc: false
folder: mydoc
---

**Об этом документе**:

Здесь представлены решения некоторых задач 
[демонстрационного варианта ЕГЭ по информатике 2021](https://4ege.ru/index.php?do=download&id=12500).

Решения даются с кратким описанием алгоритма и концентрируются в основном на демонстрации возможностей языка.

Решения сбалансированы по простоте записи и восприятия в балансе с новыми возможностями.

В сети можно встретить либо более длинные и непонятные решения на старом языке Паскаль либо переусложнённые и малопонятные для школьника решения с использованием всех возможностей языка. Ни тот ни другой стиль записи программ нами не рекомендуется.

**О PascalABC.NET**:

PascalABC.NET - современный диалект языка программирования Паскаль, позволяющий записывать код компактно и понятно, используя современные языковые возможности. Это позволяет записывать программу яснее и как следствие сократить число возможных ошибок на ЕГЭ по информатике, связанных с волнением и другими субъективными причинами.

Данный текст составлен разработчиками языка и рассматривает ряд вопросов, связанных с использованием PascalABC.NET при сдаче ЕГЭ по информатике. Он ориентирован:

* на школьников, использующих при сдаче ЕГЭ PascalABC.NET как язык реализации программ
* на преподавателей, которые при подготовке школьников к сдаче ЕГЭ по информатике используют PascalABC.NET

***Важно!*** Данный текст не рассматривает вопросы, связанные с методикой решения задач. Он лишь описывает то, как на PascalABC.NET сделать запись алгоритмов лучше, сохранив при этом эффективность. 

PascalABC.NET имеет множество языковых возможностей и множество стилей программирования, поскольку обобщает современные языковые и библиотечные возможности сразу нескольких современных языков программирования (C#, Python, Kotlin).

При решении задач ЕГЭ по информатике мы рекомендуем использовать лишь ***ограниченный набор возможностей PascalABC.NET***, которые делают текст программы яснее и короче, позволяя концентрироваться на сути алгоритма, а не на технических деталях. 

**К базовым возможностям языка, рекомендуемым нами при решении задач ЕГЭ, относятся**:

1. Описания переменных внутри блока в том месте, где они впервые потребовались. Это ликвидирует длинные перечни описания переменных до beginа основной программы, ухудшающие читаемость и лёгкость написания программы.
2. Автовывод типа переменной при описании с инициализацией (`var a := 1`).
3. Использование описания счётчика цикла `for` в заголовке цикла (`for var i`).
4. Функции ввода вида `ReadInteger`, `ReadReal`, `ReadInteger2` и т.д., позволяющие одной строкой описывать и вводить переменную в любом месте операторного блока программы (`var a := ReadInteger`).
5. Процедуры вывода `Print`, `Println`, автоматически разделяющие элементы вывода пробелами.
6. Цикл `loop` - аналог цикла for, использующийся когда счётчик цикла не нужен.
7. Кортежи и распаковка кортежей в переменные, называемая также множественным присваиванием: `(a,b) := (1,1)`.

Кроме того, в некоторых задачах уместно использование ***лямбда-выражений*** как параметров стандартных методов.

**Все представленные здесь решения сбалансированно сочетают простоту и понятность записи и использование новых возможностей**. 

**Задача 17**
Рассматривается множество целых чисел, принадлежащих числовому
отрезку [1016; 7937], которые делятся на 3 и не делятся на 7, 17, 19, 27.
Найдите количество таких чисел и максимальное из них.
В ответе запишите два целых числа: сначала количество, затем
максимальное число.

**Решение 1**

```pascal
begin
  var count := 0;
  var max := -MaxInt;
  for var x := 1016 to 7937 do
    if (x mod 3 = 0) and (x mod 7 <> 0) and (x mod 17 <> 0) and 
       (x mod 19 <> 0) and (x mod 27 <> 0) then
    begin
      count += 1;
      if x > max then
        max := x;
    end;
  Print(count,max);
end.
```
**Ответ**. 
1568 7935 


**Решение 2**. Использование методов Divs и DivsAny

```pascal
begin
  var count := 0;
  var max := -MaxInt;
  for var x := 1016 to 7937 do
    if x.Divs(3) and not x.DivsAny(7, 17, 19, 27) then
    begin
      count += 1;
      if x > max then
        max := x;
    end;
  Print(count,max);
end.
```

**Решение 2а**. Заметим, что максимальный элемент является последним удовлетворяющим условию

```pascal
begin
  var count := 0;
  var last := 0;
  for var x := 1016 to 7937 do
    if x.Divs(3) and not x.DivsAny(7, 17, 19, 27) then
    begin
      count += 1;
      last := x;
    end;
  Print(count,last);
end.
```

**Решение 3**. Использование последовательностей
```pascal
begin
  // Рассмотрим последовательность целых от 1016 до 7937, делящихся на 3 и не делящихся ни на одно из 7, 17, 19, 27
  var seq := (1016..7937).Where(x -> x.Divs(3) and not x.DivsAny(7, 17, 19, 27));
  // Выведем количество элементов этой последовательности и ее максимальный элемент
  Print(seq.Count,seq.Max);
end.
```

**Замечание**. Аналогично предыдущему вместо `seq.Max` можно использовать `seq.Last`


**Задача 25**

Напишите программу, которая ищет среди целых чисел, принадлежащих
числовому отрезку [174457; 174505], числа, имеющие ровно два различных
натуральных делителя, не считая единицы и самого числа. Для каждого
найденного числа запишите эти два делителя в таблицу на экране с новой
строки в порядке возрастания произведения этих двух делителей. Делители
в строке таблицы также должны следовать в порядке возрастания.

**Решение 1**

Для получения всех делителей стставим функцию, которая будет помещать все получаемые делители в список.
Это неэффективно (нужны только числа с ровно двумя делителями), но для приводимых на ЕГЭ значений 
программа выполняется мгновенно, поэтому писать более оптимальный алгоритм не следует.

```pascal
function Divisors(N: integer): List<integer>;
begin
  Result := new List<integer>;
  for var i:=2 to N-1 do
    if N.Divs(i) then
      Result.Add(i);
end;

begin
  for var N := 174457 to 174505 do
  begin
    var d := Divisors(N);
    if d.Count = 2 then
      Println(d[0],'|',d[1]);
  end;
end.
```

**Ответ**. 
```
3 | 58153
7 | 24923
59 | 2957 
13 | 13421
149 | 1171 
5 | 34897
211 | 827
2 | 87251 
```

**Решение 2** 

Без использования функции

```pascal
begin
  for var N := 174457 to 174505 do
  begin
    var d := new List<integer>;
    for var i:=2 to N-1 do
      if N mod i = 0 then
        d.Add(i);
    if d.Count = 2 then
      Println(d[0],'|',d[1]);
  end;
end.
```

**Решение 3** 

Более эффективное, в котором список делителей не пополняется если уже содержит более двух делителей.
Это решение - на случай очень больших значений N, что совершенно невозможно на ЕГЭ

```pascal
begin
  for var N := 174457 to 174505 do
  begin
    var d := new List<integer>;
    for var i:=2 to N-1 do
    begin  
      if N mod i = 0 then
        d.Add(i);
      if d.Count > 2 then // Это условие даёт более эффективное решение
        break;
    end;  
    if d.Count = 2 then
      Println(d[0],'|',d[1]);
  end;
end.

```

**Задача 26**

Системный администратор раз в неделю создаёт архив пользовательских
файлов. Однако объём диска, куда он помещает архив, может быть меньше,
чем суммарный объём архивируемых файлов.
Известно, какой объём занимает файл каждого пользователя.
По заданной информации об объёме файлов пользователей и свободном
объёме на архивном диске определите максимальное число пользователей,
чьи файлы можно сохранить в архиве, а также максимальный размер
имеющегося файла, который может быть сохранён в архиве, при условии,
что сохранены файлы максимально возможного числа пользователей.

**Входные данные**.

В первой строке входного файла находятся два числа: S – размер свободного
места на диске (натуральное число, не превышающее 10 000)
и N – количество пользователей (натуральное число, не превышающее
1000). В следующих N строках находятся значения объёмов файлов каждого
пользователя (все числа натуральные, не превышающие 100), каждое
в отдельной строке.
Запишите в ответе два числа: сначала наибольшее число пользователей, чьи
файлы могут быть помещены в архив, затем максимальный размер
имеющегося файла, который может быть сохранён в архиве, при условии,
что сохранены файлы максимально возможного числа пользователей.

**Пример входного файла**:
```
100 4
80
30
50
40
```
При таких исходных данных можно сохранить файлы максимум двух
пользователей. Возможные объёмы этих двух файлов 30 и 40, 30 и 50 или 40
и 50. Наибольший объём файла из перечисленных пар – 50, поэтому ответ
для приведённого примера:

**Решение 1**

```pascal
begin 
  Assign(input, '26.txt'); 
  var (S,N) := ReadInteger2;
  var data := ReadArrInteger(N);
  Sort(data);  
  var (total,count) := (0,0);
  while (count < N) and (total + data[count] <= S) do
  begin
    total += data[count];
    count += 1;
  end;
  var delta := S - total;
  Println(count, data.Last(x -> x - data[count-1] <= delta));
end. 
```

**Ответ**. 
```
568 50 
```

**Задача 27**

Имеется набор данных, состоящий из пар положительных целых чисел.
Необходимо выбрать из каждой пары ровно одно число так, чтобы сумма
всех выбранных чисел не делилась на 3 и при этом была максимально
возможной. Гарантируется, что искомую сумму получить можно.
Программа должна напечатать одно число – максимально возможную
сумму, соответствующую условиям задачи.

**Входные данные**.

Даны два входных файла (файл A и файл B), каждый из которых содержит
в первой строке количество пар N (1 ≤ N ≤ 100000). Каждая из следующих
N строк содержит два натуральных числа, не превышающих 10 000.

**Пример организации исходных данных во входном файле**:
```
6
1 3
5 12
6 9
5 4
3 3
1 1
```
Для указанных входных данных значением искомой суммы должно быть
число 32.
В ответе укажите два числа: сначала значение искомой суммы для файла А,
затем для файла B.
Предупреждение: для обработки файла B не следует использовать
переборный алгоритм, вычисляющий сумму для всех возможных вариантов,
поскольку написанная по такому алгоритму программа будет выполняться
слишком долго.

**Решение 1**

```pascal
begin
  Assign(input,'27-b.txt');
  var (s, d) := (0, MaxInt);
  var n := ReadInteger;
  loop n do
  begin
    var (a,b) := ReadInteger2;
    s += Max(a,b);
    var diff := Abs(a-b);
    if diff mod 3 <> 0 then
      d := Min(d, diff)
  end;  
  if s mod 3 <> 0 then
    Print(s)
  else Print(s-d)
end.
```

**Ответ**. 
```
127127 399762080 
```


{% include links.html %}
