---
title: Массивы в PascalABC.NET
keywords: styles
last_updated: 19.12.2020
sidebar: mydoc_sidebar
permalink: school_arrays.html
toc: true
folder: mydoc
---

В PascalABC.NET рекомендуется использовать динамические массивы. В отличие от статических, они имеют огромное количество методов и операций, просты в создании, заполнении и выводе.

### Описание и выделение памяти

Динамический массив описывается так:
```pascal
begin
  var a: array of integer;
end.
```

Память под динамический массив a выделяется в момент работы программы:
```pascal
begin
  var a: array of integer;
  var n := ReadInteger;
  a := new integer[n];
end.
```

Здесь - первое преимущество динамических массивов - в переменной a может храниться массив любого размера, память выделяется в процессе работы программы. Кроме того, выделенная память гарантированно автоматически заполняется нулевыми значениями.

Можно совместить описание и выделение памяти - тип динамического массива выводится автоматически:
```pascal
begin
  var n := ReadInteger;
  var a := new integer[n];
end.
```

### Индексация в динамических массивах и использование статических массивов

Динамические массивы индексируются с нуля - это эффективно. В качестве индексов в динамических массивах могут выступать только целые.

Статические массивы тем не менее иногда удобно использовать - в задачах, где индексы либо символьные, либо по-существу начинаются не с нуля. Например, для подсчёта количества слов на каждую букву может использоваться стаический массив
```pascal
  var a := array ['a'..'z'] of integer;
```

Заполнение статических массивов - увы - производится в цикле. Кроме того, они не помнят свою длину и передача таких массивов в качестве параметров подпрограмм связана с техническими сложностями 40-летней давности, не нужными начинающим.


### Простейшее заполнение

Важную роль играют функции заполнения динамических массивов. Перед заполнением они выделяют для массива память, поэтому в одной строке можно совмещать описание, выделение памяти и заполнение.

Простейшее заполнение - набором значений:
```pascal
var a := |1,3,3,7,9|;
```

Заполнение диапазоном целых или символьных значений делается с использованием функции Arr:
```pascal
var a := Arr(1..9);
var b := Arr('a'..'z');
```

Заполнение определённым значением осуществляется с помощью операции умножения массива на число:
```pascal
begin
  var n := ReadInteger;
  var a := |0| * n; // массив из n нулей
end.
```

Для заполнения можно также использовать функцию ArrFill:
```pascal
begin
  var n := ReadInteger;
  var a := ArrFill(n,0); // массив из n нулей
end.
```

Для заполнения массива случайными значениями следует использовать 
```pascal
begin
  var n := ReadInteger;
  var a := ArrRandomInteger(n); // по умолчанию значения от 0 до 100
  var a1 := ArrRandomInteger(n,1,10); // случайные от 1 до 10
  var r := ArrRandomReal(n); // по умолчанию значения от 0 до 10
  var r1 := ArrRandomReal(n,2,5); // случайные вещественные от 2 до 5
end.
```

**Не рекомендуется** использовать алгоритм для заполнения массива случайными в каждой задаче:
```pascal
begin
  var n := ReadInteger;
  var a := new integer[n];
  for var i:=0 to n-1 do
    a[i] := Random(0,100);
end.
```
Повторять этот текст в каждой задаче - странно. Для этого есть стандартные функции.



### Ввод и вывод элементов массива

Для ввода элементов массива базовых типов используются функции
```pascal
begin
  var n := ReadInteger;
  var a := ReadArrInteger(n);
  var r := ReadArrReal(n);
  var s := ReadArrString(n);
  // ...
end.
```

Стандартная процедура вывода Write или Print выводит значения в массиве в квадратных скобках черезх запятую:
```pascal
begin
  var a := Arr(1..9);
  Print(a); // [1,2,3,4,5,6,7,8,9]
end.
```

Однако лучше всего для вывода воспользоваться методом Print, выводящим все значения в массиве через пробел:
```pascal
begin
  var a := Arr(1..9);
  a.Print; // 1 2 3 4 5 6 7 8 9 
end.
```

**Не рекомендуется** вводить и выводить элементы массива в цикле
```pascal
begin
  var n := ReadInteger;
  var a := new integer[n];
  for var i:=0 to n-1 do
    a[i] := ReadInteger;
end.
```
Повторять этот текст в каждой задаче - странно. Для этого есть стандартные функции.


### Циклы по массиву

Для обработки элементов массива используются следующие циклы:

1. Цикл for по индексам (если требуется менять элементв или нужна информация об индексах)
```pascal
for var i:=0 to a.Length-1 do
  a[i] *= 2;
```

2. Цикл foreach по элементам (если индексы не видны и мы не меняем массив)
```pascal
var sum := 0;
foreach var x in a do
  sum += x;
```

3. Цикл foreach по индексам 
```pascal
foreach var i in a.Indices do
  a[i] += 2;
```

4. Цикл foreach по диапазону индексов 
```pascal
var (K,L) := ReadInteger2;
foreach var i in K..L do
  a[i] := 777;
```

**Пример**. Найти количество чётных элементов, стоящих на чётных местах

```pascal
begin
  var a := ArrRandomInteger(10);
  a.Println; 
  var count := 0;
  foreach var i in a.Indices do
    if i.IsEven and a[i].IsEven then
      count += 1;
  Print(count);    
end.
```

### Методы массива

Массивы содержат большое количество стандартных методов:

```pascal
a.Length - длина массива
a.Min - минимальный элемент в массиве
a.Max - максимальный элемент в массиве
a.IndexMin - индекс первого минимального элемента в массиве
a.IndexMax - индекс первого максимального элемента в массиве
a.Sum - сумма элементов в числовом массиве
a.Product - произведение элементов в числовом массиве
a.Average - среднее элементов в числовом массиве
a.First - первый элемент в массиве
a.Last - последний элемент в массиве
a.IndexOf(x) - индекс первого значения x или -1 если не найдено
a.Replace(x,y) - заменить в массиве все значения x на y
```

Кроме того, доступны процедуры 
```pascal
Sort(a) - сортировка элементов по возрастанию
SortDescending(a) - сортировка элементов по убыванию
Reverse(a) - инвертирование элементов массива
```


**Методика**. Обращаем внимание, что в методических целях естественно рассказывать, как эти алгоритмы устроены "внутри".
Но потом следует пользоваться стандартными алгоритмами, а не заставлять учеников во всех задачах использовать рукописные сортировки или рукописный поиск минимума. Например, рекомендуется показать, как накопить сумму элементов массива:

```pascal
begin
  var a := ArrRandomInteger(10);
  a.Println; 
  var sum := 0;
  foreach var x in a do
    sum += x;
  Print(sum);    
end.
```

Здесь следует обратить внимание, что этот алгоритм может быть легко модифицирован в алгоритм нахождения суммы элементов по условию: например, всех чётных элементов:

```pascal
begin
  var a := ArrRandomInteger(10);
  a.Println; 
  var sum := 0;
  foreach var x in a do
    if x.IsEven then
      sum += x;
  Print(sum);    
end.
```

Отметим, что заполнение случайными и вывод - это технические части программы, которые делаются в PascalABC.NET в одну строку, позволяя концентрироваться на алгоритме.

Если условие надо накладывать на индексы, то в этом случае (и только в этом случае) следует использовать цикл for по индексам:
```pascal
begin
  var a := ArrRandomInteger(10);
  a.Println; 
  var sum := 0;
  for var i:=0 to a.Length-1 do
    if i.IsEven then
      sum += a[i];
  Print(sum);    
end.
```

Для нахождения суммы без условия необходимо использовать стандартный метод a.Sum:
```pascal
begin
  var a := ArrRandomInteger(10);
  a.Println; 
  Print(a.Sum);    
end.
```

Отметим также, что для поиска суммы по условию также имеется короткая однострочная запись. Она требует использование стандартного метода Where с параметром, являющимся лямбда-выражением. Лямбда-выражения мы будем рассматривать далее: 
```pascal
begin
  var a := ArrRandomInteger(10);
  a.Println; 
  Print(a.Where(x -> x.IsEven).Sum);
end.
```

**Методика**. Поскольку данная запись использована здесь впервые, обращаем внимание на её высокую универсальность: алгоритмы фильтрации и поиска суммы не слиты в один алгоритм, а используются порознь один за другим, что позволяет:
1. Лучше читать код (потому что он записан компактно и методами с понятными и очевидными названиями)
2. Лучше модифицировать код
3. Решать более сложные и более прикладные задачи за одно и то же время урока

Далее лямбда-выражения объясняются подробно и тщательно и используются повсеместно.

### Операции с массивами

```pascal
x in a - возвращает true если значение x содержится в a
a1 + a2 - возвращает массив, образованный слиянием массивов a1 и a2
a1 * n - возвращает массив, состоящий из n раз повторенных значений массива a
```

## Лямбда-выражения

Лямбда-выражения - базовый примитив программирования на PascalABC.NET. При обучении начинающих они возникают как параметры стандартных подпрограмм и методов.

Учителю психологически трудно перейти на использование лямбда-выражений по нескольким причинам:
- лямбда-выражения кажутся сложными
- лямбда-выражения кажутся относящимися лишь к профессиональному программированию
- нигде в доступной учебной литературе не используются лямбда-выражения

Мы попытаемся развеять эти мифы. 

Итак: **лямбда-выражения - это просто**.

Лямбда-выражение - это **функция**. Функция отображает параметр на значение. Например, квадратичная функция в школе записывается как

```
f(x) = x * x
```
Её можно записать также в виде:
```
f: x -> x * x
```
что означает, что функция с именем f сопоставляет каждому `x` значение `x*x`. 

Запись `x -> x * x` и называется в PascalABC.NET лямбда-выражением или лямбда-функцией. Заметим, что в отличие от предыдущей записи лямбда-функция не имеет имени. Именно поэтому часто лямбда-функция называется **безымянной функцией**.

Другие примеры лямбда-функций: 

Линейная функция:
```
x -> 2*x + 3
```

Функция, проверяющая, чётно ли x, и возвращающая True если чётно и False в противном случае:
```
x -> x mod 2 = 0
```

Чаще всего лямбда-функции встречаются как параметры других функций. Далее будет рассмотрено множество подобных примеров.

## Генераторы массивов с лямбда-функциями

Для генерации массивов с элементами, заполненными по некоторому правилу, используется функция ArrGen. У неё - две основные модификации.

* Генерация по формуле a[i] = f(i)
```
var a := ArrGen(10,i->f(i));
```

Здесь первый параметр - количество элементов массива, второй - лямбда функция, переводящая индекс элемента в значение. Нумерация i начинается с нуля. 

Можно начать нумерацию с другого значения, указав третий параметр. Например, чтобы заполнить массив квадратами натуральных чисел начиная с 1, требуется написать: 

```
var a := ArrGen(10,i->i*i,1);
```

* Генерация по рекуррентной формуле, в которой следующий элемент определяется по предыдущему.
```
var a := ArrGen(10,1,x->x+2);
```

Здесь генерируется массив из 10 элементов, первый равен 1, а каждый последующий больше предыдущего на 2

```
var a := ArrGen(10,1,x->x*2);
```

Здесь генерируется массив из 10 элементов, первый равен 1, а каждый последующий больше предыдущего в 2 раза

## Срезы

## Последовательности

## Списки

## Двумерные массивы (матрицы)

Как и в случае с одномерными массивами, мы рекомендуем использовать двумерные динамические массивы - они имеют огромное количество методов и просто передаются в подпрограммы.
Для простоты мы будем называть их матрицами как в математике и считать, что в записи a[i,j] индекс i - это номер строки, а индекс j - номер столбца.

Описание двумерного массива, выделение под него памяти и заполнение значениями выполняется следующим образом:

```
var a := array [,] of integer;
a := new integer[3,4];
a[0,0] := 1; a[0,1] := 2; a[0,2] := 3; a[0,3] := 4;
a[1,0] := 1; a[1,1] := 2; a[1,2] := 3; a[1,3] := 4;
a[2,0] := 1; a[2,1] := 2; a[2,2] := 3; a[2,3] := 4;
```

Это можно совместить в одной строке:

```
var a := Matr(|1,2,3,4|,|5,6,7,8|,|9,10,11,12|);
```

Для вывода 

## Строки



{% include links.html %}
1
